import numpy as np

def banker_algorithm(Max, Need, Available, Allocated, Request, process_id):
    """
    银行家算法实现
    
    参数:
        Max (np.array): 最大需求矩阵 (n_processes × n_resources)
        Need (np.array): 需求矩阵 (n_processes × n_resources)
        Available (np.array): 可用资源向量 (1 × n_resources)
        Allocated (np.array): 已分配矩阵 (n_processes × n_resources)
        Request (np.array): 进程请求资源向量 (1 × n_resources)
        process_id (int): 发起请求的进程ID
        
    返回:
        bool: 是否分配成功
        str: 分配结果信息
        np.array: 新的Max矩阵
        np.array: 新的Need矩阵
        np.array: 新的Available矩阵
        np.array: 新的Allocated矩阵
    """
    n_processes, n_resources = Max.shape
    
    # 1. 检查请求是否小于等于Need
    if not all(Request <= Need[process_id]):
        return False, "Error: Request exceeds Need.", Max, Need, Available, Allocated
    
    # 2. 检查请求是否小于等于Available
    if not all(Request <= Available):
        return False, "Error: Request exceeds Available resources.", Max, Need, Available, Allocated
    
    # 3. 尝试分配资源（临时修改矩阵）
    temp_Available = Available - Request
    temp_Allocated = Allocated.copy()
    temp_Allocated[process_id] += Request
    temp_Need = Need.copy()
    temp_Need[process_id] -= Request
    
    # 4. 检查安全性
    if is_safe(temp_Available, temp_Allocated, temp_Need):
        # 分配成功，更新全局状态
        Available = temp_Available
        Allocated = temp_Allocated
        Need = temp_Need
        return True, "Request granted. System is safe.", Max, Need, Available, Allocated
    else:
        return False, "Request denied. System would be unsafe.", Max, Need, Available, Allocated

def is_safe(Available, Allocated, Need):
    """
    安全性检查算法
    
    参数:
        Available (np.array): 可用资源向量
        Allocated (np.array): 已分配矩阵
        Need (np.array): 需求矩阵
        
    返回:
        bool: 系统是否安全
    """
    n_processes, n_resources = Need.shape
    work = Available.copy()
    finish = np.zeros(n_processes, dtype=bool)
    safe_sequence = []
    
    while True:
        found = False
        for i in range(n_processes):
            if not finish[i] and all(Need[i] <= work):
                # 进程i可以执行
                work += Allocated[i]
                finish[i] = True
                safe_sequence.append(i)
                found = True
                break
        
        if not found:
            break
    
    if all(finish):
        print("Safe sequence:", safe_sequence)
        return True
    else:
        return False

# 示例测试
if __name__ == "__main__":
    # 示例数据（3个进程，4种资源）
    Max = np.array([
        [7, 5, 3, 2],
        [3, 2, 2, 2],
        [9, 0, 2, 2]
    ])
    
    Allocated = np.array([
        [0, 1, 0, 0],
        [2, 0, 0, 1],
        [3, 0, 2, 1]
    ])
    
    Need = Max - Allocated
    Available = np.array([3, 3, 2, 2])
    
    print("Initial State:")
    print("Max:\n", Max)
    print("Allocated:\n", Allocated)
    print("Need:\n", Need)
    print("Available:", Available)
    
    # 进程1请求资源 [1, 0, 2, 1]
    Request = np.array([1, 0, 2, 1])
    process_id = 1
    
    success, message, new_Max, new_Need, new_Available, new_Allocated = banker_algorithm(
        Max, Need, Available, Allocated, Request, process_id
    )
    
    print("\nResult:")
    print(message)
    if success:
        print("New Max:\n", new_Max)
        print("New Allocated:\n", new_Allocated)
        print("New Need:\n", new_Need)
        print("New Available:", new_Available)
